Gemini's Implementation Plan

This is a comprehensive implementation plan for your Codex32-to-BIP39 terminal tool. This plan is designed to be architecturally compatible with SeedSigner (using the Model-View-Controller pattern) while running purely in your Windows PowerShell terminal environment.
Phase 1: Environment & Project Setup

Since you are working in PowerShell within Windsurf, we will set up a standard Python virtual environment. We will use the embit library for BIP39 functionality, as this is the exact cryptographic library SeedSigner uses, ensuring your code is "port-ready."

1. Directory Structure Create a folder named codex32-bridge with the following structure to enforce the MVC pattern:
Plaintext

codex32-bridge/
├── venv/                   # Virtual Environment
├── src/
│   ├── __init__.py
│   ├── model.py            # Logic (Codex32 validation, Bit manipulation, BIP39 conversion)
│   ├── view.py             # UI (Terminal prompts, Box-by-Box entry display)
│   ├── controller.py       # Orchestration (Flow control)
│   └── main.py             # Entry point
├── tests/                  # Unit tests for your sacrificial keys
├── requirements.txt
└── README.md

2. Dependencies Run these commands in PowerShell to set up your environment:
PowerShell

python -m venv venv
.\venv\Scripts\Activate.ps1
pip install codex32 embit
pip freeze > requirements.txt

    codex32: The Ben Westgate library for checksums and SSSS.

    embit: The library SeedSigner uses for Bitcoin primitives (BIP39/BIP32).

Phase 2: MVP Implementation (Single "S" Share)

This phase focuses on the "Happy Path": entering a valid S-share box-by-box, verifying it, and converting it.
Step 1: The Model (src/model.py)

This file will handle the "heavy lifting" and math. It should not know anything about the terminal or the user.

    Function 1: validate_codex32_string(codex_str)

        Use codex32.decode(hrp, codex_str) to check if the string is valid.

        Crucial: Ensure the Header is ms (Mainnet) and Separator is 1.

        Return a boolean or raise specific exceptions (e.g., InvalidChecksumError).

    Function 2: convert_codex32_to_bip39(codex_str)

        Decoding: Decode the Bech32 string into 5-bit integers.

        Payload Extraction: Identify the 26 data characters (excluding header, k, ident, index, and checksum).

        Bit Manipulation (The Tricky Part):

            Convert the 26 chars (5-bit values) into a bitstream (26×5=130 bits).

            Truncation: Discard the last 2 bits to get exactly 128 bits.

            Byte Conversion: Convert these 128 bits into 16 bytes.

        BIP39 Generation: Pass these 16 bytes to embit.bip39.mnemonic_from_bytes(bytes) to get the 12-word string.

        Return the mnemonic string.

Step 2: The View (src/view.py)

This file handles all print and input operations.

    Function: display_welcome(): Simple ASCII header.

    Function: get_box_input(box_number):

        Prompt the user: Enter character for Box [box_number]:

        Input Sanitization: Convert input to uppercase immediately. Reject input if length > 1 (unless it's the specific "ms" header box, though usually, we skip entering the "ms1" part box-by-box and just assume it/hardcode it for the logic, or ask for it explicitly).

        Recommendation: Since the user has a worksheet, ask for "Box 1-2 (ms)" once, then iterate 3 to 48.

    Function: display_mnemonic(mnemonic): Print the result clearly.

    Function: display_error(message): Format error messages (e.g., in red text if using a color library, or just capitalized).

Step 3: The Controller (src/controller.py)

This ties it all together.

    Workflow:

        Call view.display_welcome().

        Initialize an empty list/string for the secret.

        The Loop: Iterate from Box 1 to 48.

            Call view.get_box_input(i).

            Store the character.

            Optional UX: Validate that characters are in the Bech32 charset as they are typed to catch typos early (a "V1.5" feature).

        Construct the full Codex32 string.

        Call model.validate_codex32_string().

            If Invalid: Call view.display_error() and ask to retry (error correction will allow us to indicate retry in specific boxes in V2, but restart for MVP).

        Call model.convert_codex32_to_bip39().

        Call view.display_mnemonic().

Step 4: MVP Testing (tests/)

Create a test_manual.py script.

    Use your "sacrificial keys" here. We can use the Test Vector 2 examples from Bip93 as it has an S share plus the non-reconstructed A and C shares:
		Test vector 2

		This example shows generating a new master seed using "random" shares, as well as deriving an additional share, using k=2 and an identifier of NAME. Although codex32 strings are canonically all lowercase, it's also valid to use all uppercase.

		Share with index A: MS12NAMEA320ZYXWVUTSRQPNMLKJHGFEDCAXRPP870HKKQRM

		Share with index C: MS12NAMECACDEFGHJKLMNPQRSTUVWXYZ023FTR2GDZMPY6PN

		Derived share with index D: MS12NAMEDLL4F8JLH4E5VDVULDLFXU2JHDNLSM97XVENRXEG
		Recovered secret seed with index S: MS12NAMES6XQGUZTTXKEQNJSJZV4JV3NZ5K3KWGSPHUH6EVW

		Hardcode a known valid Codex32 string and assert that model.convert_codex32_to_bip39 returns the expected 12 words.

		This verifies your bit-truncation logic is correct before you type it in manually.

Phase 3: V2 Implementation (Error Correction & SSSS)

Once the MVP works, implement these features without changing the architecture.
1. Error Correction (The "Helper" Feature)

    Update Model: Add attempt_error_correction(invalid_codex_str).

        Use codex32 library's error correction methods.

        If it finds a candidate, return it and have the user verify a match with their worksheet.

    Update Controller:

        If validation fails in Step 5, call attempt_error_correction.

        If a correction is found, call view.confirm_correction(original, corrected) to ask the user "Did you mean X?".

        If confirmed, proceed to conversion.

2. Shamir's Secret Sharing (The "Recovery" Feature)

    if the user enters a share with a share index other than S, we know the secret must be reconstructed from multiple shares and we et our (k) value from Box 4 - this is the amount of shares the user must enter.

    Update Controller:

        We can help the user by prefilling boxes 1-8, and have the user start with box 9 on additional share entries

        Loop the "Box Entry" process k times (e.g., "Enter Share 1...", "Enter Share 2...").

        Store all shares in a list.

    Update Model: Add recover_secret(share_list).

        Use codex32.interpolate() (or specific recovery function) to derive the "S" share.

        Pass the recovered "S" share to the existing convert_codex32_to_bip39 function.

Migration to SeedSigner (Future Context)

By strictly separating view.py, you make migration easy:

    Terminal: view.py uses print() / input().

    SeedSigner: You will replace view.py with a Screen class that uses the joystick and LCD. The model.py and controller.py logic will remain largely unchanged.
	
	Challenges: we will have to create a bech32 alphabet keyboard (which we may need to modify from the stock keyboard UI within seedsigner), along with a character entry flow that makes sense on the small screen UI.

Immediate Next Steps for You

    Create the Folder Structure as defined in Phase 1.

    Generate your Test Vectors: Use the python library or the website tools to generate:

        1 Valid Codex32 S-share.

        The corresponding valid BIP39 Seed Phrase (so you know the "Right Answer").

    Begin coding model.py: Focus strictly on the bitwise truncation logic first, as that is the most likely place for "off-by-one" bit errors.